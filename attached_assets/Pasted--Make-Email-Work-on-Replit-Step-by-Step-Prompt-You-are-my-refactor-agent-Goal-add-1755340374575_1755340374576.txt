---

# ✅ “Make Email Work on Replit” – Step-by-Step Prompt

You are my refactor agent. Goal: add **reliable email sending** that works on **Replit** without domain-wide delegation. Implement a pluggable email service with **Resend or SendGrid** first, and **Gmail SMTP (App Password)** as a fallback. Include tests, a health route, and a test endpoint.

**Constraints**

* Stack: Node.js (TypeScript) server under `server/` (Fastify or Express) with `src/`.
* Keep changes ≤150 lines per commit. Create small, focused commits per step.
* Read secrets from env (Replit Secrets). Never hardcode keys.
* Emails should be HTML + plain text. Use a tiny templating helper.
* Add rate-limit, input validation (zod), retries for transient failures, and structured logs.
* Provide **Success checks** at the end of each step.

---

## STEP 1 — Dependencies & folder layout

**Edits allowed:** `server/**`, root scripts if needed.

**Do:**

1. Install deps (choose provider based on env vars at runtime):

   * Core: `zod`, `pino`
   * Providers: `resend`, `@sendgrid/mail`, `nodemailer`
   * Optional: `p-retry` (or write a simple backoff)
2. Create structure:

```
server/
  src/
    email/
      index.ts            # provider selection (resend/sendgrid/smtp)
      providers/
        resend.ts
        sendgrid.ts
        smtp_gmail.ts
      templates/
        base.ts           # simple template wrapper (subject, html, text)
        homeCenter.ts     # example template
    routes/
      email.test.route.ts # POST /v1/email/test
    util/env.ts           # zod env validation for email vars
```

**Env (Replit Secrets):**

* For **Resend**: `RESEND_API_KEY`
* For **SendGrid**: `SENDGRID_API_KEY`, `MAIL_FROM`
* For **Gmail SMTP**: `SMTP_USER`, `SMTP_PASS`, `MAIL_FROM`
* Optional: `MAIL_PROVIDER` = `resend | sendgrid | smtp`

**Success checks:**

* Code compiles.
* `MAIL_PROVIDER` is optional; default auto-picks the first available configured provider.

---

## STEP 2 — Env validation

**Edits allowed:** `server/src/util/env.ts`

**Do:**

* Create zod schema to validate email config:

```ts
import { z } from "zod";

export const EmailEnv = z.object({
  MAIL_PROVIDER: z.enum(["resend","sendgrid","smtp"]).optional(),
  RESEND_API_KEY: z.string().optional(),
  SENDGRID_API_KEY: z.string().optional(),
  SMTP_USER: z.string().optional(),
  SMTP_PASS: z.string().optional(),
  MAIL_FROM: z.string().email().optional(), // required for sendgrid/smtp
});

export type EmailEnv = z.infer<typeof EmailEnv>;

export function getEmailEnv(): EmailEnv {
  const parsed = EmailEnv.safeParse(process.env);
  if (!parsed.success) {
    // don’t throw here; provider chooser will decide if we have enough
    console.warn("Email env not fully configured:", parsed.error.flatten());
  }
  return parsed.data;
}
```

**Success checks:**

* Build passes; no runtime throw yet.

---

## STEP 3 — Providers

**Edits allowed:** `server/src/email/providers/*.ts`

**Do (implement each):**

**`providers/resend.ts`**

```ts
import { Resend } from "resend";

export async function sendWithResend({ apiKey, from, to, subject, html, text }:{
  apiKey: string, from: string, to: string | string[], subject: string, html: string, text?: string
}) {
  const r = new Resend(apiKey);
  const res = await r.emails.send({
    from,
    to: Array.isArray(to) ? to : [to],
    subject,
    html,
    text,
  });
  if (res.error) throw new Error(`Resend error: ${res.error.message}`);
  return res.data?.id || "ok";
}
```

**`providers/sendgrid.ts`**

```ts
import sg from "@sendgrid/mail";

export async function sendWithSendgrid({ apiKey, from, to, subject, html, text }:{
  apiKey: string, from: string, to: string | string[], subject: string, html: string, text?: string
}) {
  sg.setApiKey(apiKey);
  const [res] = await sg.send({
    from, to, subject, html, text,
  });
  if (res.statusCode >= 400) throw new Error(`SendGrid ${res.statusCode}`);
  return res.headers["x-message-id"] || "ok";
}
```

**`providers/smtp_gmail.ts`**

```ts
import nodemailer from "nodemailer";

export async function sendWithSmtpGmail({ user, pass, from, to, subject, html, text }:{
  user: string, pass: string, from: string, to: string | string[], subject: string, html: string, text?: string
}) {
  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: { user, pass }, // App Password recommended
  });
  const info = await transporter.sendMail({
    from, to, subject, html, text
  });
  return info.messageId || "ok";
}
```

**Success checks:**

* Each module exports a function that throws on failure, returns a message id on success.

---

## STEP 4 — Template helpers

**Edits allowed:** `server/src/email/templates/*.ts`

**Do:**

**`templates/base.ts`**

```ts
export function wrapHtml(content: string) {
  return `
  <div style="font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;line-height:1.5;">
    ${content}
    <hr style="margin-top:24px;border:none;border-top:1px solid #eee"/>
    <div style="color:#777;font-size:12px">This message was sent by Parent Portal.</div>
  </div>`;
}

export function toText(html: string) {
  return html.replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim();
}
```

**`templates/homeCenter.ts`**

```ts
export function homeCenterEmail({ studentName, message }:{
  studentName: string; message: string;
}) {
  const content = `
    <h3>Update for ${escapeHtml(studentName)}</h3>
    <p>${escapeHtml(message)}</p>
  `;
  return content;
}
function escapeHtml(s:string){return s.replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m]!));}
```

**Success checks:**

* Pure functions; easy to unit test later.

---

## STEP 5 — Provider selector

**Edits allowed:** `server/src/email/index.ts`

**Do:**

```ts
import pRetry from "p-retry";
import { getEmailEnv } from "../util/env";
import { wrapHtml, toText } from "./templates/base";
import { sendWithResend } from "./providers/resend";
import { sendWithSendgrid } from "./providers/sendgrid";
import { sendWithSmtpGmail } from "./providers/smtp_gmail";

type SendArgs = { to: string|string[]; subject: string; html: string; text?: string; from?: string; };

export async function sendEmail(args: SendArgs) {
  const env = getEmailEnv();
  const from = args.from || env.MAIL_FROM || "no-reply@example.com"; // fallback

  const task = async () => {
    // explicit provider
    if (env.MAIL_PROVIDER === "resend" && env.RESEND_API_KEY) {
      return sendWithResend({ apiKey: env.RESEND_API_KEY, from, ...args });
    }
    if (env.MAIL_PROVIDER === "sendgrid" && env.SENDGRID_API_KEY) {
      return sendWithSendgrid({ apiKey: env.SENDGRID_API_KEY, from, ...args });
    }
    if (env.MAIL_PROVIDER === "smtp" && env.SMTP_USER && env.SMTP_PASS) {
      return sendWithSmtpGmail({ user: env.SMTP_USER, pass: env.SMTP_PASS, from, ...args });
    }
    // auto-pick based on available secrets
    if (env.RESEND_API_KEY)   return sendWithResend({ apiKey: env.RESEND_API_KEY, from, ...args });
    if (env.SENDGRID_API_KEY) return sendWithSendgrid({ apiKey: env.SENDGRID_API_KEY, from, ...args });
    if (env.SMTP_USER && env.SMTP_PASS)
      return sendWithSmtpGmail({ user: env.SMTP_USER, pass: env.SMTP_PASS, from, ...args });

    throw new Error("No email provider configured");
  };

  return pRetry(task, { retries: 2, factor: 2 }); // basic retry
}

export function renderHomeCenterEmail(input:{studentName:string; message:string;}){
  const html = wrapHtml(require("./templates/homeCenter").homeCenterEmail(input));
  return { html, text: toText(html) };
}
```

**Success checks:**

* Builds; choosing provider by env works.

---

## STEP 6 — Test route with validation + rate limit

**Edits allowed:** `server/src/routes/email.test.route.ts`, server entry to register route + CORS

**Do (Fastify example):**

```ts
import { FastifyInstance } from "fastify";
import { z } from "zod";
import { sendEmail, renderHomeCenterEmail } from "../email";

export async function emailTestRoute(app: FastifyInstance) {
  app.post("/v1/email/test", {
    config: { rateLimit: { max: 5, timeWindow: "1 minute" } }
  }, async (req, reply) => {
    const Body = z.object({
      to: z.string().email(),
      studentName: z.string().min(1),
      message: z.string().min(1)
    });
    const body = Body.parse(req.body);
    const { html, text } = renderHomeCenterEmail({ studentName: body.studentName, message: body.message });
    const id = await sendEmail({
      to: body.to,
      subject: `Update for ${body.studentName}`,
      html,
      text
    });
    return reply.code(202).send({ ok: true, id });
  });
}
```

Register it in your server `index.ts` and ensure CORS allows your Replit web origin:

```ts
import cors from "@fastify/cors";
// ...
await app.register(cors, { origin: true }); // dev
await app.register(require("./routes/email.test.route").emailTestRoute);
```

**Success checks:**

* `POST /v1/email/test` with JSON body sends an email and returns `{ ok: true, id }`.

---

## STEP 7 — Quick manual test instructions (put in PR/commit message)

* In Replit Secrets:

  * **Preferred** (Resend): set `RESEND_API_KEY`, `MAIL_FROM` (e.g., `Your App <noreply@yourdomain.com>` *after verifying domain in Resend*)
  * **Or** (SendGrid): set `SENDGRID_API_KEY`, `MAIL_FROM`
  * **Or** (Gmail SMTP): set `SMTP_USER`, `SMTP_PASS` (App Password), `MAIL_FROM`
* Start server on Replit.
* `curl` test:

```bash
curl -X POST https://<your-repl-url>/v1/email/test \
  -H "Content-Type: application/json" \
  -d '{"to":"youraddress@example.com","studentName":"Alex","message":"Hello from Parent Portal!"}'
```

* Expect: `{"ok":true,"id":"..."}` and an email in your inbox.

---

## STEP 8 — Safety/Deliverability notes (add to README)

* **SPF/DKIM/DMARC**: if you use a custom domain, verify & set DNS in the email provider (Resend/SendGrid) for best inbox placement.
* **Rate limit** ingress to prevent abuse.
* **Log** and **redact** secrets/PII.
* **Retry** transient 4xx/5xx; don’t retry validation failures.

---

**End of prompt.** Please execute STEP 1 → STEP 7 with small commits and show me the final routes and env keys you detected.

---

### What you need to do in Replit (your side)

1. Pick a provider:

   * **Resend (easy & reliable):** add `RESEND_API_KEY` and verify a sender/domain; set `MAIL_FROM`.
   * **SendGrid:** add `SENDGRID_API_KEY`, set `MAIL_FROM`.
   * **Gmail SMTP:** add `SMTP_USER` (your Gmail address), `SMTP_PASS` (App Password), and `MAIL_FROM`.
2. Start the server, hit `POST /v1/email/test`.
